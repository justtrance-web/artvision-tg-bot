/**
 * Artvision Bot v3.0
 * Ğ‘Ğ•Ğ— ASANA (Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾)
 * + Ğ“Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ñ‹Ğµ: Yandex SpeechKit (STT) + Claude (Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ)
 * + Mini App Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ
 */

import { NextRequest, NextResponse } from 'next/server';

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '';
const ADMIN_IDS = (process.env.ADMIN_IDS || '161261562,161261652').split(',').map(Number);
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY || '';
const YANDEX_API_KEY = process.env.YANDEX_API_KEY || '';
const YANDEX_FOLDER_ID = process.env.YANDEX_FOLDER_ID || 'b1g3skikcv7e3aehpu26';
const GITHUB_TOKEN = process.env.GITHUB_TOKEN || '';

const PORTAL_URL = 'https://artvision-portal.vercel.app/webapp.html';
const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TELEGRAM API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface InlineButton {
  text: string;
  url?: string;
  web_app?: { url: string };
  callback_data?: string;
}

async function sendMessage(chatId: number, text: string, buttons?: InlineButton[][]) {
  const body: any = {
    chat_id: chatId,
    text,
    parse_mode: 'HTML',
    disable_web_page_preview: true
  };
  
  if (buttons) {
    body.reply_markup = { inline_keyboard: buttons };
  }
  
  await fetch(`${TELEGRAM_API}/sendMessage`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
}

async function answerCallback(callbackId: string, text?: string) {
  await fetch(`${TELEGRAM_API}/answerCallbackQuery`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      callback_query_id: callbackId,
      text: text || ''
    })
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GITHUB API (Ğ´Ğ»Ñ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğ³Ğ¾ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ´Ğ¾Ğ¼)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface GitHubFile {
  content: string;
  sha: string;
}

async function getGitHubFile(repo: string, path: string): Promise<GitHubFile | null> {
  try {
    const resp = await fetch(
      `https://api.github.com/repos/${repo}/contents/${path}`,
      { headers: { Authorization: `token ${GITHUB_TOKEN}` } }
    );
    if (!resp.ok) return null;
    const data = await resp.json();
    return {
      content: Buffer.from(data.content, 'base64').toString('utf-8'),
      sha: data.sha
    };
  } catch {
    return null;
  }
}

async function updateGitHubFile(repo: string, path: string, content: string, sha: string, message: string): Promise<boolean> {
  try {
    const resp = await fetch(
      `https://api.github.com/repos/${repo}/contents/${path}`,
      {
        method: 'PUT',
        headers: {
          Authorization: `token ${GITHUB_TOKEN}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message,
          content: Buffer.from(content).toString('base64'),
          sha
        })
      }
    );
    return resp.ok;
  } catch {
    return false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YANDEX SPEECHKIT (STT)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function recognizeSpeech(audioData: ArrayBuffer): Promise<string> {
  try {
    const response = await fetch(
      `https://stt.api.cloud.yandex.net/speech/v1/stt:recognize?folderId=${YANDEX_FOLDER_ID}&lang=ru-RU`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Api-Key ${YANDEX_API_KEY}`,
          'Content-Type': 'audio/ogg'
        },
        body: audioData
      }
    );
    
    if (!response.ok) {
      console.error('Yandex STT error:', response.status);
      return '';
    }
    
    const data = await response.json();
    return data.result || '';
  } catch (error) {
    console.error('Speech recognition error:', error);
    return '';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLAUDE API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function askClaude(prompt: string, systemPrompt?: string): Promise<string> {
  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1024,
        system: systemPrompt || 'Ğ¢Ñ‹ â€” Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº SEO-Ğ°Ğ³ĞµĞ½Ñ‚ÑÑ‚Ğ²Ğ° Artvision. ĞÑ‚Ğ²ĞµÑ‡Ğ°Ğ¹ ĞºÑ€Ğ°Ñ‚ĞºĞ¾ Ğ¸ Ğ¿Ğ¾ Ğ´ĞµĞ»Ñƒ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼.',
        messages: [{ role: 'user', content: prompt }]
      })
    });
    
    if (!response.ok) return '';
    const data = await response.json();
    return data.content?.[0]?.text || '';
  } catch {
    return '';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOICE HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleVoice(chatId: number, fileId: string, userId: number, userName: string) {
  try {
    // 1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»
    const fileResp = await fetch(`${TELEGRAM_API}/getFile?file_id=${fileId}`);
    const fileData = await fileResp.json();
    
    if (!fileData.ok) {
      await sendMessage(chatId, 'âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ');
      return;
    }
    
    const filePath = fileData.result.file_path;
    const audioResp = await fetch(`https://api.telegram.org/file/bot${BOT_TOKEN}/${filePath}`);
    const audioBuffer = await audioResp.arrayBuffer();
    
    // 2. Ğ Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ñ‘Ğ¼ Ñ€ĞµÑ‡ÑŒ
    const recognizedText = await recognizeSpeech(audioBuffer);
    
    if (!recognizedText) {
      await sendMessage(chatId, 'âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ñ‚ÑŒ Ñ€ĞµÑ‡ÑŒ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·.');
      return;
    }
    
    // 3. ĞĞ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· Claude
    const analysis = await askClaude(
      `ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑĞºĞ°Ğ·Ğ°Ğ»: "${recognizedText}"
      
ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸ Ñ‚Ğ¸Ğ¿ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°:
1. Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¿Ñ€Ğ¾ SEO, Ğ¼Ğ°Ñ€ĞºĞµÑ‚Ğ¸Ğ½Ğ³, ÑĞ°Ğ¹Ñ‚Ñ‹ â€” Ğ¾Ñ‚Ğ²ĞµÑ‚ÑŒ Ğ½Ğ° Ğ½ĞµĞ³Ğ¾
2. Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ â€” ÑĞºĞ°Ğ¶Ğ¸ Ñ‡Ñ‚Ğ¾ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°
3. Ğ•ÑĞ»Ğ¸ Ğ½ĞµĞ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾ â€” Ğ¿Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¸ ÑƒÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ñ‚ÑŒ

ĞÑ‚Ğ²ĞµÑ‡Ğ°Ğ¹ ĞºÑ€Ğ°Ñ‚ĞºĞ¾.`,
      'Ğ¢Ñ‹ â€” Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº SEO-Ğ°Ğ³ĞµĞ½Ñ‚ÑÑ‚Ğ²Ğ° Artvision.'
    );
    
    await sendMessage(chatId, `ğŸ™ <i>"${recognizedText}"</i>\n\n${analysis}`);
    
  } catch (error) {
    console.error('Voice handler error:', error);
    await sendMessage(chatId, 'âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMMAND HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleStart(chatId: number, userName: string) {
  const text = `ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚, ${userName}!

Ğ¯ Ğ±Ğ¾Ñ‚ <b>Artvision</b> â€” SEO-Ğ°Ğ³ĞµĞ½Ñ‚ÑÑ‚Ğ²Ğ°.

ğŸ“Š <b>ĞŸĞ¾Ñ€Ñ‚Ğ°Ğ»</b> â€” ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞ°Ğ¹Ñ‚Ğ¾Ğ²
ğŸ™ <b>Ğ“Ğ¾Ğ»Ğ¾Ñ</b> â€” Ğ·Ğ°Ğ´Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ¼

<i>ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ¼ĞµĞ½Ñ Ğ´Ğ»Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº Ğ¿Ğ¾Ñ€Ñ‚Ğ°Ğ»Ñƒ</i>`;

  await sendMessage(chatId, text, [
    [
      { text: 'ğŸ“Š ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ñ€Ñ‚Ğ°Ğ»', web_app: { url: PORTAL_URL } }
    ],
    [
      { text: 'ğŸ• Ğ’Ñ€ĞµĞ¼Ñ', callback_data: 'cmd_time' }
    ]
  ]);
}

// âš ï¸ ASANA Ğ’Ğ Ğ•ĞœĞ•ĞĞĞ ĞĞ¢ĞšĞ›Ğ®Ğ§Ğ•ĞĞ
async function handleTasks(chatId: number) {
  await sendMessage(chatId, `âš ï¸ <b>Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°</b>

Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Asana Ğ½Ğ° Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğ¸.

Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Asana Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ:
ğŸ“± <a href="https://app.asana.com">app.asana.com</a>`, [
    [{ text: 'ğŸ“Š ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ñ€Ñ‚Ğ°Ğ»', web_app: { url: PORTAL_URL } }]
  ]);
}

async function handleOverdue(chatId: number) {
  await sendMessage(chatId, `âš ï¸ <b>Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°</b>

Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Asana Ğ½Ğ° Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğ¸.`);
}

async function handleWeek(chatId: number) {
  await sendMessage(chatId, `âš ï¸ <b>Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°</b>

Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Asana Ğ½Ğ° Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğ¸.`);
}

async function handleWorkload(chatId: number, isAdmin: boolean) {
  if (!isAdmin) {
    await sendMessage(chatId, 'ğŸ”’ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²');
    return;
  }
  await sendMessage(chatId, `âš ï¸ <b>Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°</b>

Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Asana Ğ½Ğ° Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğ¸.`);
}

async function handlePositions(chatId: number) {
  await sendMessage(chatId, `ğŸ“ˆ <b>ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ÑĞ°Ğ¹Ñ‚Ğ¾Ğ²</b>

ĞÑ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ğ°Ğ» Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸:`, [
    [{ text: 'ğŸ“Š ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ñ€Ñ‚Ğ°Ğ»', web_app: { url: PORTAL_URL } }]
  ]);
}

async function handleMyId(chatId: number, userId: number, userName: string) {
  const isAdmin = ADMIN_IDS.includes(userId);
  await sendMessage(chatId, `ğŸ†” <b>Ğ’Ğ°Ñˆ Telegram ID:</b> <code>${userId}</code>\nğŸ‘¤ Ğ˜Ğ¼Ñ: ${userName}\n${isAdmin ? 'âœ… Ğ’Ñ‹ Ğ°Ğ´Ğ¼Ğ¸Ğ½' : 'âŒ Ğ’Ñ‹ Ğ½Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½'}`);
}

async function handleTime(chatId: number) {
  const now = new Date();
  const msk = new Date(now.getTime() + 3 * 60 * 60 * 1000);
  const timeStr = msk.toISOString().slice(11, 19);
  const dateStr = msk.toISOString().slice(0, 10).split('-').reverse().join('.');
  
  await sendMessage(chatId, `ğŸ• <b>ĞœĞ¾ÑĞºĞ¾Ğ²ÑĞºĞ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ:</b>\n\n<code>${timeStr}</code>\nğŸ“… ${dateStr}`);
}

async function handleHelp(chatId: number) {
  await sendMessage(chatId, `ğŸ“– <b>ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ğ±Ğ¾Ñ‚Ğ°:</b>

/start â€” Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ
/positions â€” ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ÑĞ°Ğ¹Ñ‚Ğ¾Ğ²
/time â€” Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ
/myid â€” Ğ’Ğ°Ñˆ Telegram ID
/help â€” Ğ­Ñ‚Ğ° ÑĞ¿Ñ€Ğ°Ğ²ĞºĞ°

ğŸ™ <b>Ğ“Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ñ‹Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ:</b>
ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğµ â€” Ñ Ğ¾Ñ‚Ğ²ĞµÑ‡Ñƒ Ğ½Ğ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ

ğŸ“Š <b>ĞŸĞ¾Ñ€Ñ‚Ğ°Ğ»:</b>
ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ¼ĞµĞ½Ñ Ğ²Ğ½Ğ¸Ğ·Ñƒ`, [
    [{ text: 'ğŸ“Š ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ñ€Ñ‚Ğ°Ğ»', web_app: { url: PORTAL_URL } }]
  ]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALLBACK HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleCallback(callbackId: string, data: string, chatId: number, userId: number) {
  const isAdmin = ADMIN_IDS.includes(userId);
  
  await answerCallback(callbackId);
  
  switch (data) {
    case 'cmd_tasks': await handleTasks(chatId); break;
    case 'cmd_week': await handleWeek(chatId); break;
    case 'cmd_overdue': await handleOverdue(chatId); break;
    case 'cmd_workload': await handleWorkload(chatId, isAdmin); break;
    case 'cmd_time': await handleTime(chatId); break;
    default:
      if (data.startsWith('task_')) {
        await sendMessage(chatId, 'âš ï¸ Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°');
      }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function GET() {
  return NextResponse.json({ 
    status: 'Artvision Bot v3.0 (without Asana)',
    webhook: '/api/telegram'
  });
}

export async function POST(request: NextRequest) {
  try {
    const update = await request.json();
    
    // Callback query (ĞºĞ½Ğ¾Ğ¿ĞºĞ¸)
    if (update.callback_query) {
      const cb = update.callback_query;
      await handleCallback(
        cb.id,
        cb.data,
        cb.message?.chat?.id,
        cb.from?.id
      );
      return NextResponse.json({ ok: true });
    }
    
    const message = update.message;
    if (!message) return NextResponse.json({ ok: true });
    
    const chatId = message.chat?.id;
    const userId = message.from?.id;
    const userName = message.from?.first_name || 'User';
    const text = message.text || '';
    const isAdmin = ADMIN_IDS.includes(userId);
    
    // Ğ“Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
    if (message.voice) {
      await handleVoice(chatId, message.voice.file_id, userId, userName);
      return NextResponse.json({ ok: true });
    }
    
    // ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
    const command = text.split(' ')[0].toLowerCase();
    
    switch (command) {
      case '/start':
      case '/help':
        await (command === '/start' ? handleStart(chatId, userName) : handleHelp(chatId));
        break;
      case '/tasks':
        await handleTasks(chatId);
        break;
      case '/overdue':
        await handleOverdue(chatId);
        break;
      case '/week':
        await handleWeek(chatId);
        break;
      case '/positions':
        await handlePositions(chatId);
        break;
      case '/workload':
        await handleWorkload(chatId, isAdmin);
        break;
      case '/myid':
      case '/id':
        await handleMyId(chatId, userId, userName);
        break;
      case '/time':
        await handleTime(chatId);
        break;
      default:
        // ĞĞ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚ â€” Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°ĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· Claude
        if (text && !text.startsWith('/')) {
          const response = await askClaude(text);
          if (response) {
            await sendMessage(chatId, response);
          }
        }
    }
    
    return NextResponse.json({ ok: true });
  } catch (error) {
    console.error('Bot error:', error);
    return NextResponse.json({ ok: true });
  }
}
